<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>집중 : FACE BREAK TEST</title>
    <!-- 영어 웹폰트 (영문 타이틀용) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=BBH+Sans+Bartle&display=swap" rel="stylesheet">
    <!-- 한글 폰트 -->
    <style>
        @font-face {
            font-family: 'KakaoBigFont';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2503@1.0/KakaoBigSans-Regular.woff2') format('woff2');
            font-weight: 400;
            font-display: swap;
        }
        @font-face {
            font-family: 'KakaoBigFont';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2503@1.0/KakaoBigSans-Bold.woff2') format('woff2');
            font-weight: 700;
            font-display: swap;
        }
        @font-face {
            font-family: 'KakaoBigFont';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2503@1.0/KakaoBigSans-ExtraBold.woff2') format('woff2');
            font-weight: 800;
            font-display: swap;
        }
    </style>
    <style>
        /* ===== Design system (진단서 컨셉) ===== */
        :root{
            --bg:#ffffff;
            --ink:#111;
            --muted:#666;
            --line:#111;
            --beige:#faf7f0;
            --paper:#f2efe7; /* 아이보리 */
            --paper-2:#e7e2d6; /* 타깃 블록 기본 */
            --paper-3:#dcd6c7; /* CPT용 타깃 블록 */
            --accent:#e60023; /* 포인트 레드 */
            --frame-gap:clamp(16px,3vw,28px);
            /* 게임 고정 크기 (예전과 유사한 체감값) */
            --stage-max-h: 560px;
            --stage-min-h: 420px;
        }
        *{box-sizing:border-box}
        html,body{height:100%}
        body{
            margin:0;
            background:var(--bg);
            color:var(--ink);
            font-family:'KakaoBigFont', system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans KR', sans-serif;
            overflow:hidden; /* 한 화면에 수납 */
        }
        /* 인셋 프레임 */
        .frame{
            position:fixed;
            inset:var(--frame-gap);
            border:1px solid var(--line);
            pointer-events:none;
            z-index:1;
        }
        .corner{
            position:fixed;
            z-index:2;
            width:24px;
            height:24px;
            border:1px solid var(--line);
            background:transparent;
        }
        .corner.tl{
            left:calc(var(--frame-gap) - 1px);
            top:calc(var(--frame-gap) - 1px);
            border-right:none;
            border-bottom:none;}
        .corner.tr{
            right:calc(var(--frame-gap) - 1px);
            top:calc(var(--frame-gap) - 1px);
            border-left:none;
            border-bottom:none;}
        .corner.bl{
            left:calc(var(--frame-gap) - 1px);
            bottom:calc(var(--frame-gap) - 1px);
            border-right:none;
            border-top:none;}
        .corner.br{
            right:calc(var(--frame-gap) - 1px);
            bottom:calc(var(--frame-gap) - 1px);
            border-left:none;
            border-top:none;}

        /* ====== 전체 레이아웃: 좌(게임) – 우(사이드) ====== */
        .shell{
            position:relative;
            z-index:3;
            height:calc(100svh - 2*var(--frame-gap));
            margin:var(--frame-gap);
            display:grid;
            grid-template-columns: 1fr 360px; /* 게임 우선, 사이드 고정 */
            gap:22px;
        }

        /* 좌측: 게임 래퍼(배경 그리드/용지 텍스처) */
        .stage-wrap{
            position:relative;
            border:1px solid var(--line);
            border-radius:12px;
            overflow:hidden;
            background:
                linear-gradient(transparent 39px, rgba(0,0,0,.04) 40px) repeat-y,
                linear-gradient(90deg, transparent 39px, rgba(0,0,0,.04) 40px) repeat-x,
                var(--beige);
            background-size: 100% 40px, 40px 100%, auto;
            display:grid;
            place-items:center; /* 중앙에 고정 크기 스테이지 배치 */
            padding:10px;
        }

        /* ===== 핵심: 스테이지 크기 고정(너무 커지지 않게) ===== */
        .stage{
            position:relative;
            height: clamp(var(--stage-min-h), calc(100% - 40px), min(var(--stage-max-h), calc(100svh - 2*var(--frame-gap) - 80px)));
            aspect-ratio: 16/9;
            width: auto;
            max-width: calc(100% - 20px);
            border-radius:12px;
            overflow:hidden;
            background: var(--paper);
        }

        /* 비디오/캔버스: 프라이버시 블러 유지 */
        video{
            position:absolute;
            inset:0;
            width:100%;
            height:100%;
            object-fit:cover;
            transform:scaleX(-1);
            z-index:1;
            filter: blur(26px) brightness(0.9) saturate(0.9) contrast(1.05);
        }
        canvas{
            position:absolute;
            inset:0;
            width:100%;
            height:100%;
            object-fit:cover;
            transform:scaleX(-1);
            z-index:2;
        }

        /* HUD / 범례 / 진행바 / 메시지 */
        .hud{
            position:absolute;
            left:12px;
            top:12px;
            z-index:30;
            background:#ffffffcc;
            border:1px solid var(--line);
            padding:8px 10px;
            border-radius:8px;
            font-variant-numeric:tabular-nums;
        }
        .row{
            display:flex;
            gap:12px;
            align-items:center;
            flex-wrap:wrap;
            font-size:12px;
        }
        .row b{
            font-weight:800
        }
        .subhint{
            font-size:12px;
            color:var(--muted);
            margin-top:4px
        }

        .legend{
            position:absolute;
            right:12px;
            top:12px;
            z-index:31;
            background:#ffffffcc;
            border:1px solid var(--line);
            padding:6px 10px;
            border-radius:8px;
            font-size:12px;
            display:none;
        }
        .dot{
            display:inline-block;
            width:10px;
            height:10px;
            border-radius:2px;
            margin-right:6px;
            vertical-align:middle;
        }
        .dot-target{
            background:var(--paper-2);
            border:1px solid var(--line);
        }
        .dot-nogo{
            background:var(--accent);
            border:1px solid var(--line);
        }

        .meter{
            position:absolute;
            left:12px;
            right:12px;
            bottom:12px;
            height:10px;
            border-radius:999px;
            background:#fff;
            border:1px solid var(--line);
            overflow:hidden;
            z-index:30;
        }
        .meter > span{
            display:block;
            height:100%;
            background:var(--accent);
            width:0%;
        }

        .msg{
            position:absolute;
            left:50%;
            top:50%;
            transform:translate(-50%,-50%);
            background:#ffffffd0;
            border:1px solid var(--line);
            padding:10px 14px;
            border-radius:10px;
            font-weight:800;
            opacity:0;
            transition:opacity .25s;
            text-align:center;
            z-index:30;
            color:var(--ink);
        }
        .msg.show{
            opacity:1;
        }

        /* ========================= 결과 모달 (진단서 레이아웃 강화) ========================= */
        .result{
            position:fixed;
            inset:0;
            display:none;
            background:#00000060;
            z-index:70;
            padding:0;
            overflow:auto;
        }

        /* 카드: 상단 헤더/식별부 + 지표요약 + 해석 + 권장 + 서명부 로 밀도 ↑ */
        .card{
            background:var(--paper);
            border:1px solid var(--line);
            border-radius:14px;
            padding:0; /* 내부 섹션이 자체 여백을 가짐 */
            width:min(900px, 94vw);
            margin:calc(var(--frame-gap)) auto;
            box-shadow: 8px 8px 0 var(--line);
            display:grid;
            grid-template-rows: auto auto auto auto auto; /* 헤더/요약/해석/권장/서명 */
            overflow:hidden;
        }

        /* 헤더(기관/제목/메타) */
        .report-head{
            padding:14px 18px 12px 18px;
            background: repeating-linear-gradient(0deg, rgba(255,255,255,0) 0 28px, rgba(0,0,0,.05) 28px 29px), #fff;
            border-bottom:1px solid var(--line);
            display:grid;
            grid-template-columns: 1fr auto;
            gap:10px;
            align-items:end;
        }
        .head-left .facility{
            font-size:12px;
            letter-spacing:.04em;
            display:inline-flex;
            gap:8px;
            align-items:center;
        }
        .head-left .facility .mark{
            width:10px;
            height:10px;
            background:var(--accent);
            border:1px solid var(--line);
            display:inline-block;
        }
        .head-left h2{
            margin:6px 0 0 0;
            font-size:18px;
            letter-spacing:.02em;
        }
        .head-right{
            text-align:right;
            font-size:12px;
            line-height:1.4;
        }
        .head-right .meta{
            display:grid;
            grid-template-columns:auto 1fr;
            gap:4px 10px;
        }
        .head-right .meta div:nth-child(odd){
            color:var(--muted);
        }

        /* 배지(평가 초점)와 스냅숏 KPI */
        .construct-bar{
            padding:10px 18px;
            display:grid;
            grid-template-columns: auto 1fr;
            gap:10px 14px;
            align-items:center;
            border-bottom:1px dashed var(--line);
            background:#fff;
        }
        .badge{
            display:inline-block;
            padding:8px 14px;
            border-radius:10px;
            font-size:13px;
            font-weight:800;
            background:#fff;
            color:var(--ink);
            border:2px solid var(--accent);
            box-shadow: 2px 2px 0 var(--line);
        }
        .kpi-chips{
            display:flex;
            gap:8px;
            flex-wrap:wrap;
            font-size:12px;
        }
        .kpi-chips .chip{
            border:1px solid var(--line);
            border-radius:999px;
            padding:6px 10px;
            background:var(--paper);
        }

        /* 요약 섹션: 3열로 밀도 ↑, 기준범위 패널 추가 */
        .summary{
            padding:12px 18px;
            display:grid;
            grid-template-columns:1fr 1fr 1fr;
            gap:10px;
            margin:0;
            background:var(--paper);
        }
        .block{
            background:#fff;
            border:1px solid var(--line);
            border-radius:10px;
            padding:10px;
        }
        .block h3{
            margin:0 0 8px 0;
            font-size:13px;
            color:#000;
        }
        .kv{
            display:grid;
            grid-template-columns: 1fr auto;
            row-gap:6px;
            column-gap:10px;
            font-size:13px;
        }
        .ok{
            color:#0a7a0a;
            font-weight:800;
        }
        .warn{
            color:#a05b00;
            font-weight:800;
        }
        .error{
            color:var(--accent);
            font-weight:800;
        }

        /* 기준 범위(정적 안내) */
        .ref{
            font-size:12px;
            line-height:1.5;
        }
        .ref ul{
            margin:6px 0 0 18px;
            padding:0;
        }
        .ref li{
            margin:2px 0;
        }

        /* 해석 패널(강조) */
        .assess-wrap{
            display:grid;
            grid-template-columns: 2fr 1fr;
            gap:10px;
            padding:12px 18px;
            background:#fff;
            border-top:2px solid var(--line);
            border-bottom:2px solid var(--line);
        }
        .assess{
            background:#fff;
            border:2px solid var(--accent);
            border-radius:12px;
            padding:12px;
            box-shadow: 4px 4px 0 var(--line);
        }
        .assess h3{
            margin:0 0 10px 0;
            font-size:14px;
            color:#000;
        }
        #rAssess{
            font-size:16px;
            font-weight:800;
            line-height:1.6;
        }
        .assess .help{
            font-size:11px;
            color:var(--muted);
            margin-top:8px;
        }

        /* 권장 섹션(정적 가이던스) */
        .reco{
            padding:10px 18px;
            background:var(--paper);
            display:grid;
            grid-template-columns: 1fr 1fr;
            gap:10px;
        }
        .reco .panel{
            background:#fff;
            border:1px dashed var(--line);
            border-radius:10px;
            padding:10px;
            font-size:12px;
            line-height:1.6;
        }

        /* 서명/확인 섹션 */
        .sign{
            padding:12px 18px;
            background:#fff;
            display:grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap:12px;
            border-top:1px solid var(--line);
        }
        .sign .cell{
            border:1px solid var(--line);
            border-radius:8px;
            padding:10px;
            background:var(--paper);
            font-size:12px;
            min-height:66px;
            display:grid;
            align-content:end;
        }
        .sign .label{
            color:var(--muted);
            font-size:11px;
            margin-bottom:6px;
        }
        .sign .line{
            border-top:1px solid var(--line);
            margin-top:8px;
            padding-top:6px;
        }

        /* 버튼 영역(카드 내부 하단) */
        .actions{
            display:flex;
            gap:8px;
            justify-content:center;
            padding:12px 18px;
            background:#fff;
            border-top:1px dashed var(--line);
        }
        .actions button{
            padding:10px 14px;
            font-size:13px;
        }
        .actions .secondary{
            background:#fff;
        }

        /* 우측: 사이드(제목/툴바/안내) */
        .side{
            height:100%;
            display:grid;
            grid-template-rows: auto auto 1fr auto;
            gap:12px;
            padding:10px;
            box-sizing:border-box;
            overflow:auto;
            position:relative; /* 음악 컨트롤을 위한 상대 위치 */
        }

        .badge-top{
            display:inline-flex;
            align-items:center;
            gap:10px;
            padding:6px 12px;
            border:1px solid var(--line);
            border-radius:999px;
            font-size:12px;
            letter-spacing:.04em;
            background:#fff;
            width:max-content;
        }
        .badge-top .dot{
            width:6px;
            height:6px;
            background:var(--accent);
            border-radius:50%;
            display:inline-block}

        .eng-title{
            font-family:"BBH Sans Bartle", system-ui, sans-serif;
            font-weight:800;
            letter-spacing:-0.01em;
            line-height:.92;
            font-size:clamp(26px,3.4vw,42px);
            border-bottom:1px solid var(--line);
            padding:6px 0 8px;
        }

        h1{
            margin:0;
            padding:6px 0 0;
            font-size:clamp(16px,2.4vw,22px);
            font-weight:800;
            color:var(--ink);
        }

        .header-note{
            color:var(--muted);
            font-size:12px;
            margin-top:6px;
            border-bottom:1px dashed var(--line);
            padding-bottom:10px;
        }

        /* 툴바 (세로 스택) */
        .toolbar{
            display:grid;
            gap:8px;
            align-content:start;
            border-bottom:1px solid var(--line);
            padding-bottom:10px;
        }

        .pill{
            background:#fff;
            border:1px solid var(--line);
            padding:8px 12px;
            border-radius:12px;
            display:flex;
            align-items:center;
            gap:8px;
            width:100%;
            white-space:nowrap;
        }
        .pill .label{font-weight:800;white-space:nowrap}
        .pill *{
            white-space:nowrap;
        }

        button, input[type="range"], select{
            background:#fff;
            color:var(--ink);
            border:1px solid var(--line);
            border-radius:12px;
            padding:10px 12px;
            cursor:pointer;
            font-weight:700;
            width:100%;
        }

        .select{
            appearance:none;
            -webkit-appearance:none;
            -moz-appearance:none;
            background:#fff;
            border:1px solid var(--line);
            border-radius:10px;
            padding:10px 12px;
            font-weight:700;
            font-family:'KakaoBigFont',system-ui,sans-serif;
            letter-spacing:.01em;
            min-width: 230px;
            flex:1 1 auto;
        }
        .select:focus{
            outline:2px solid #1110;
            box-shadow: 0 0 0 2px var(--line) inset;
        }

        /* 게임 시작 버튼: 색 대비와 이중 보더로 가독성 강화 */
        /* 카메라 시작(기본 강조: 빨강) */
        button.primary{
            background:var(--accent);
            color:#fff;
            border:1px solid var(--line);
            box-shadow:2px 2px 0 var(--line);
            font-weight:700;
            font-size:14px;
        }
        button.primary:hover{
            filter:brightness(1.03);
        }
        button.primary:active{
            filter:brightness(.98);
        }

        /* 게임 시작(60초) — 시각적 최우선 강조 */
        #btnStart{
            background:#111;
            color:#fff;
            text-transform:uppercase;
            letter-spacing:.02em;
            font-weight:800;
            font-size:16px;
            border:2px solid #fff;
            box-shadow:0 0 0 2px var(--line);
        }
        #btnStart:hover{
            filter:brightness(1.06);
        }
        #btnStart:active{
            filter:brightness(.96);
        }

        button.secondary{
            background:#fff;
            border:1px solid var(--line);
        }

        /* 상태 버튼: 게임 시작 버튼 아래 */
        .status-pill{
            background:#fff;border:1px solid var(--line);padding:8px 12px;border-radius:12px;display:flex;align-items:center;gap:10px;
            font-weight:700;
            width:100%;
        }

        /* 안내 */
        .helpbox{
            border:1px solid var(--line);
            border-radius:12px;
            padding:10px;
            font-size:12px;
            line-height:1.6;
            background:#fff;
        }

        /* ===== 하단 화살표 버튼: 더 크고, 더 선명하게 ===== */
        .back-btn{
            position:fixed;
            left:calc(var(--frame-gap) + 12px);
            bottom:calc(var(--frame-gap) + 12px);
            width:72px;
            height:72px;
            border-radius:50%;
            background:var(--accent);
            color:#fff;
            border:2px solid var(--line);
            display:flex;
            align-items:center;
            justify-content:center;
            font-size:28px;
            font-weight:800;
            cursor:pointer;
            z-index:90;
            box-shadow:4px 4px 0 var(--line);
            transition:transform .08s ease, box-shadow .2s ease, filter .2s ease;
            text-decoration:none;
        }
        .back-btn:hover{
            filter:brightness(1.08);
        }
        .back-btn:active{
            transform:translateY(1px);
            box-shadow:2px 2px 0 var(--line);
        }

        /* ===== 음악 컨트롤 ===== */
        .music-controls{
            position:absolute;
            left:50%;
            top:60px;
            transform:translateX(-50%);
            display:flex;
            align-items:center;
            gap:8px;
            z-index:20;
            background:#fff;
            border:1px solid var(--line);
            border-radius:12px;
            padding:8px 12px;
            box-shadow:2px 2px 0 var(--line);
            width:fit-content;
        }
        .music-toggle{
            width:32px;
            height:32px;
            border-radius:50%;
            background:var(--accent);
            color:#fff;
            border:1px solid var(--line);
            display:flex;
            align-items:center;
            justify-content:center;
            cursor:pointer;
            font-size:14px;
            font-weight:800;
            transition:all 0.2s ease;
        }
        .music-toggle:hover{
            filter:brightness(1.1);
        }
        .music-toggle:active{
            transform:scale(0.95);
        }
        .music-toggle.muted{
            background:#666;
        }
        .volume-slider{
            width:60px;
            height:4px;
            background:#ddd;
            border-radius:2px;
            outline:none;
            cursor:pointer;
            appearance:none;
            -webkit-appearance:none;
        }
        .volume-slider::-webkit-slider-thumb{
            appearance:none;
            -webkit-appearance:none;
            width:16px;
            height:16px;
            border-radius:50%;
            background:var(--accent);
            border:1px solid var(--line);
            cursor:pointer;
        }
        .volume-slider::-moz-range-thumb{
            width:16px;
            height:16px;
            border-radius:50%;
            background:var(--accent);
            border:1px solid var(--line);
            cursor:pointer;
        }

        /* 모드 가이드 모달(원본 유지) */
        .modal{
            position:fixed;
            inset:0;
            display:none;
            place-items:center;
            background:#00000040;
            z-index:60;
            padding:16px;
        }
        .modal .sheet{
            background:#fff;
            border:1px solid var(--line);
            border-radius:14px;
            width:min(640px,92vw);
            padding:18px;
            box-shadow:8px 8px 0 var(--line);
        }
        .modal h2{
            margin:0 0 8px 0;
            text-align:center;
        }
        .modal .guide{
            background:#fff;
            border:1px dashed var(--line);
            border-radius:12px;
            padding:12px;
        }
        .modal .guide h3{
            margin:0 0 6px 0;
            font-size:14px;
        }
        .modal ul{
            margin:8px 0 0 18px;
            padding:0;
            line-height:1.6;
        }
        .modal .foot{
            display:flex;
            gap:8px;
            justify-content:center;
            margin-top:12px;
            flex-wrap:wrap;
        }
        .modal .row{
            display:flex;
            gap:10px;
            align-items:center;
            justify-content:center;
            margin-top:6px;
        }
        .modal small{
            color:var(--muted)
        }
        .check{
            display:flex;
            align-items:center;
            gap:8px;
            font-size:13px;
            color:var(--muted);
        }
        .check input{
            width:16px;
            height:16px;
        }

        /* 반응형(좁은 화면) */
        @media (max-width: 840px){
            .shell{
                grid-template-columns: 1fr 300px;
                gap:12px;
            }
            .eng-title{
                font-size:clamp(22px,4.4vw,34px);
            }
            .summary{
                grid-template-columns:1fr;
            }
            .assess-wrap{
                grid-template-columns:1fr;
            }
            .reco{
                grid-template-columns:1fr;
            }
            .hud{
                max-width:70%;
            }
            .back-btn{
                width:68px;
                height:68px;
                font-size:26px;
            }
        }
    </style>
</head>
<body>

<!-- 인셋 프레임 & 코너 라인 -->
<div class="frame" aria-hidden="true"></div>
<div class="corner tl" aria-hidden="true"></div>
<div class="corner tr" aria-hidden="true"></div>
<div class="corner bl" aria-hidden="true"></div>
<div class="corner br" aria-hidden="true"></div>

<!-- ===== 새 레이아웃 컨테이너 ===== -->
<div class="shell">
    <!-- 좌: 게임 영역 -->
    <section class="stage-wrap" aria-label="게임 화면">
        <!-- 음악 컨트롤 -->
        <div class="music-controls" id="musicControls">
            <button class="music-toggle" id="musicToggle" aria-label="음악 켜기/끄기">♪</button>
            <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="50" aria-label="음량 조절">
        </div>

        <div class="stage">
            <div class="hud" id="hud">
                <div class="row">
                    <span>TIME <b id="timeLeft">60.0s</b></span>
                    <span>STREAK <b id="streak">0.0s</b></span>
                    <span>BEST <b id="best">0.0s</b></span>
                    <span>MISS <b id="miss">0</b></span>
                    <span>COMM <b id="comm">0</b></span>
                    <span>OMISS <b id="omiss">0</b></span>
                </div>
                <div class="subhint" id="modeHint">기본 집중: 속도가 빠르게 증가합니다.</div>
            </div>

            <!-- 범례 (Go/No-Go 전용) -->
            <div class="legend" id="legend">
                <div><span class="dot dot-target"></span>타깃(맞춰도 됨)</div>
                <div><span class="dot dot-nogo"></span>금지(치면 Commission)</div>
            </div>

            <div id="msg" class="msg"></div>
            <div class="meter"><span id="bar"></span></div>
            <video id="video" playsinline muted></video>
            <canvas id="overlay"></canvas>

            <!-- 결과 카드 (진단서) -->
            <div id="result" class="result">
                <div class="card">
                    <!-- 헤더(기관/제목/메타) -->
                    <div class="report-head">
                        <div class="head-left">
                            <div class="facility"><span class="mark"></span> FOCUS BREAKOUT LAB</div>
                            <h2>세션 결과 진단서</h2>
                        </div>
                        <div class="head-right">
                            <div class="meta">
                                <div>세션 길이</div><div>60초</div>
                                <div>리포트 ID</div><div>#FB-<span style="font-variant-numeric:tabular-nums;">2024</span>-XXXX</div>
                                <div>생성 시각</div><div><span style="opacity:.85;">브라우저 시각 기준</span></div>
                            </div>
                        </div>
                    </div>

                    <!-- 평가 초점 & KPI 스냅숏 -->
                    <div class="construct-bar">
                        <span class="badge" id="rConstructBadge">-</span>
                        <div class="kpi-chips">
                            <span class="chip">MODE: <b id="rMode">-</b></span>
                            <span class="chip">BEST: <b id="rBest" class="ok">0.0초</b></span>
                            <span class="chip">AVG: <b id="rAvg">-</b></span>
                            <span class="chip">MISS: <b id="rMiss" class="warn">0</b></span>
                            <span class="chip">COMM: <b id="rComm" class="error">0</b></span>
                            <span class="chip">OMISS: <b id="rOmiss" class="warn">0</b></span>
                            <span class="chip">RT: <b id="rRT">-</b></span>
                            <span class="chip">RTσ: <b id="rRTV">-</b></span>
                        </div>
                    </div>

                    <!-- 요약(3열) + 기준 범위 -->
                    <div class="summary">
                        <div class="block">
                            <h3>요약</h3>
                            <div class="kv">
                                <div>모드</div><div id="rMode">-</div>
                                <div>최고 집중 연속</div><div id="rBest" class="ok">0.0초</div>
                                <div>평균 집중 연속(추정)</div><div id="rAvg">-</div>
                                <div>놓침</div><div id="rMiss" class="warn">0</div>
                            </div>
                        </div>
                        <div class="block">
                            <h3>오류/반응</h3>
                            <div class="kv">
                                <div>Commission(금지 반응)</div><div id="rComm" class="error">0</div>
                                <div>Omission(타깃 놓침)</div><div id="rOmiss" class="warn">0</div>
                                <div>반응 시간 평균</div><div id="rRT">-</div>
                                <div>반응 시간 변동성</div><div id="rRTV">-</div>
                            </div>
                        </div>
                        <div class="block ref">
                            <h3>참고 기준</h3>
                            <ul>
                                <li><b>BEST</b> 18초 이상: 안정 경향</li>
                                <li><b>OMISS</b> 0–2회: 양호 / 6회↑: 주의</li>
                                <li><b>COMM</b> 0–1회: 양호 / 3회↑: 억제 저하 가능</li>
                                <li><b>RTσ</b> 0.30s 이하: 변동성 낮음 / 0.50s↑: 변동성 큼</li>
                            </ul>
                        </div>
                    </div>

                    <!-- 해석 + 요약 메모 -->
                    <div class="assess-wrap">
                        <div class="assess">
                            <h3>자동 해석(참고용)</h3>
                            <div id="rAssess" class="warn">-</div>
                            <div class="help">※ 본 결과는 자가 점검 참고용이며 의료 진단을 대체하지 않습니다.</div>
                        </div>
                        <div class="assess">
                            <h3>요약 메모</h3>
                            <div style="font-size:12px; line-height:1.6;">
                                • BEST/AVG가 높을수록 지속 주의 유지가 양호합니다.<br/>
                                • COMM은 충동적 반응 억제와 관련, OMISS는 주의 누락과 관련됩니다.<br/>
                                • RTσ(표준편차)가 낮을수록 반응 일관성이 좋습니다.
                            </div>
                        </div>
                    </div>

                    <!-- 권장 (정적 가이드) -->
                    <div class="reco">
                        <div class="panel">
                            <b>권장 루틴</b><br/>
                            ① 3–4분 집중 / 1분 휴식 사이클을 3회 반복<br/>
                            ② 시각 자극을 단순화(불필요 창/알림 최소화)<br/>
                            ③ 시작 전에 4초 들숨–6초 날숨 호흡 5회
                        </div>
                        <div class="panel">
                            <b>환경 셋업 체크</b><br/>
                            • 정면 조명, 카메라 시야 확보<br/>
                            • 좌우 움직임 공간 확보(의자/상체 여유)<br/>
                            • 브라우저 탭 최소화, 방해 금지 모드
                        </div>
                    </div>

                    <!-- 액션 버튼 -->
                    <div class="actions">
                        <button id="btnRestart">다시 하기</button>
                        <button id="btnClose" class="secondary">닫기</button>
                        <button id="btnSavePNG" class="secondary">결과 저장</button>
                    </div>
                </div>
            </div>
            <!-- /결과 카드 끝 -->
        </div>
    </section>

    <!-- 우: 사이드 패널 -->
    <aside class="side" aria-label="설정 및 안내">
        <div>
            <span class="badge-top"><span class="dot"></span> ADHD SELF-CHECK</span>
            <div class="eng-title">FACE BREAK TEST</div>
            <h1>얼굴 블록깨기 — 집중 자가 점검</h1>
            <p class="header-note">이는 주의집중 패턴을 살피는 참고용 도구이며, 의료 진단을 대체하지 않습니다.</p>
        </div>

        <div class="toolbar">
            <button id="btnCam" class="primary">카메라 시작</button>
            <label class="pill"><span class="label">모드</span>
                <select id="mode" class="select">
                    <option value="classic" selected>기본 집중 (속도 빠르게 증가)</option>
                    <option value="cpt">CPT (속도 빠름 + 궤적 변동)</option>
                    <option value="gng">Go/No-Go (금지 블록 포함)</option>
                </select>
            </label>
            <button id="btnStart" disabled>게임 시작(60초)</button>
            <label class="pill"><span class="label">패들 크기</span>
                <input id="paddleSize" type="range" min="0.8" max="1.8" step="0.05" value="1.4">
            </label>
            <div class="status-pill">상태: <span id="status">대기</span></div>
        </div>

        <div class="helpbox">
            <div>• HTTPS(또는 Live Server)에서 실행 → 카메라 허용</div>
            <div>• CPT: 속도 빠름, 궤적 변동 큼(주의 일관성)</div>
            <div>• Go/No-Go: <b style="color:var(--accent)">빨간 금지(X)</b>는 피하고 타깃만 맞추기</div>
        </div>
        <div></div>
    </aside>
</div>

<!-- 이전 화면 버튼 -->
<a href="game.html" class="back-btn" id="backBtn" aria-label="이전 화면으로 돌아가기">←</a>

<!-- ▶ 모드 가이드 모달 -->
<div id="guideModal" class="modal">
    <div class="sheet">
        <h2 id="guideTitle">플레이 가이드</h2>
        <div class="guide">
            <h3 id="guideSubtitle">-</h3>
            <ul id="guideList"></ul>
        </div>
        <div class="row" style="justify-content:center; margin-top:6px;">
            <label class="check">
                <input type="checkbox" id="chkNoShow">
                <span>다음부터 이 모드에서는 가이드를 보지 않기</span>
            </label>
        </div>
        <div class="foot">
            <button id="btnGuideCancel" class="secondary">취소</button>
            <button id="btnGuideStart" class="primary">플레이 시작</button>
        </div>
        <small id="guideNote" style="display:block; text-align:center; margin-top:8px;">Tip: 조명은 정면, 카메라는 거울 모드입니다.</small>
    </div>
</div>

<!-- ===== 실행 로직 ===== -->
<script type="module">
    import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.13";

    /* ======= 엘리먼트 ======= */
    const els = {
        btnCam: document.getElementById('btnCam'),
        btnStart: document.getElementById('btnStart'),
        mode: document.getElementById('mode'),
        paddleSize: document.getElementById('paddleSize'),
        video: document.getElementById('video'),
        canvas: document.getElementById('overlay'),
        status: document.getElementById('status'),
        timeLeft: document.getElementById('timeLeft'),
        streak: document.getElementById('streak'),
        best: document.getElementById('best'),
        miss: document.getElementById('miss'),
        comm: document.getElementById('comm'),
        omiss: document.getElementById('omiss'),
        bar: document.getElementById('bar'),
        msg: document.getElementById('msg'),
        result: document.getElementById('result'),
        rMode: document.getElementById('rMode'),
        rBest: document.getElementById('rBest'),
        rAvg: document.getElementById('rAvg'),
        rMiss: document.getElementById('rMiss'),
        rComm: document.getElementById('rComm'),
        rOmiss: document.getElementById('rOmiss'),
        rRT: document.getElementById('rRT'),
        rRTV: document.getElementById('rRTV'),
        rAssess: document.getElementById('rAssess'),
        rConstructBadge: document.getElementById('rConstructBadge'),
        btnSavePNG: document.getElementById('btnSavePNG'),
        legend: document.getElementById('legend'),
        modeHint: document.getElementById('modeHint'),
        guideModal: document.getElementById('guideModal'),
        guideTitle: document.getElementById('guideTitle'),
        guideSubtitle: document.getElementById('guideSubtitle'),
        guideList: document.getElementById('guideList'),
        btnGuideStart: document.getElementById('btnGuideStart'),
        btnGuideCancel: document.getElementById('btnGuideCancel'),
        chkNoShow: document.getElementById('chkNoShow'),
    };

    /* ======= 상태 ======= */
    let faceLandmarker = null;
    let running = false;
    let gameOn = false;
    let lastTime = performance.now();
    let sessionStart = 0;
    const SESSION_SEC = 60;
    let elapsed = 0;
    let streakSec = 0;
    let bestStreak = 0;
    let misses = 0;
    let commission = 0;
    let omission = 0;
    const streakHistory = [];
    const hitIntervals = [];
    let lastHitAt = 0;
    let tDrift = 0;

    const game = {
        paddleX: 0,
        paddleBaseW: 140,
        paddleH: 14,
        ballX: 0,
        ballY: 0,
        ballVX: 220,
        ballVY: -220,
        ballR: 8,
        bricks: [],
        rows: 5,
        cols: 9,
        brickW: 80,
        brickH: 20,
        gap: 6
    };

    function setStatus(t, cls=""){
        els.status.textContent = t;
        els.status.className = cls;
    }

    function fitCanvas() {
        const rect = els.video.getBoundingClientRect();
        els.canvas.width = rect.width * devicePixelRatio;
        els.canvas.height = rect.height * devicePixelRatio;
    }

    async function setupLandmarker() {
        setStatus("모델 로딩 중…");
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.13/wasm");
        faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
            baseOptions: {
                modelAssetPath:"https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task"
            },
            runningMode: "VIDEO",
            numFaces: 1
        });
        setStatus("준비됨", "ok");
    }

    async function startCamera() {
        try {
            els.btnCam.disabled = true;
            setStatus("카메라 요청 중…");
            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    width: 1280,
                    height: 720,
                    facingMode: "user"
                },
                audio: false
            });
            els.video.srcObject = stream;
            await els.video.play();
            fitCanvas();
            addEventListener('resize', fitCanvas, { passive: true });
            if (!faceLandmarker) await setupLandmarker();
            running = true;
            els.btnStart.disabled = false;
            setStatus("카메라 연결됨", "ok");
            requestAnimationFrame(loop);
        } catch (e) {
            console.error(e);
            setStatus("카메라 실패: 권한/HTTPS 확인", "error");
            els.btnCam.disabled = false;
        }
    }

    /* 얼굴 bbox 중심 */
    function getBBox(landmarks, w, h) {
        let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
        for (const p of landmarks) {
            const x=p.x*w, y=p.y*h;
            if (x<minX) minX=x;
            if (y<minY) minY=y;
            if (x>maxX) maxX=x;
            if (y>maxY) maxY=y;
        }
        return {
            cx:(minX+maxX)/2,
            cy:(minY+maxY)/2,
            w:maxX-minX,
            h:maxY-minY
        };
    }

    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));

    /* ======= 벽돌 초기화 (GNG 금지 비율 상향) ======= */
    function initBricks(vw, vh) {
        const marginX = 16, marginTop = 16 + 44;
        game.bricks = [];
        game.brickW = Math.floor((vw - marginX*2 - game.gap*(game.cols-1)) / game.cols);
        game.brickH = 22;

        const mode = els.mode.value;
        const total = game.rows * game.cols;
        // ★ GNG 금지 블록 비율 상향: 12% → 25%
        const nogoCount = mode === "gng" ? Math.max(1, Math.round(total * 0.25)) : 0;
        const nogoSet = new Set();
        while (nogoSet.size < nogoCount) nogoSet.add(Math.floor(Math.random() * total));

        let idx = 0;
        for (let r=0;r<game.rows;r++){
            for(let c=0;c<game.cols;c++, idx++){
                const x = marginX + c*(game.brickW + game.gap);
                const y = marginTop + r*(game.brickH + game.gap);
                let type = "target";
                if (mode === "gng" && nogoSet.has(idx)) type = "nogo";
                game.bricks.push({x,y,alive:true,hp:1, type});
            }
        }
    }

    function effectivePaddleW() {
        return Math.max(90, Math.floor(game.paddleBaseW));
    }

    function resetBall(vw, vh, gentle=false) {
        game.ballX = vw/2;
        game.ballY = vh*0.7;

        const mode = els.mode.value;
        // ★ 모든 모드의 기본 속도 대폭 상향
        let base = 340; // classic: 220 → 340
        if (mode === "cpt") base = 420; // 280 → 420
        if (mode === "gng") base = 360; // 180 → 360

        const dir = Math.random()<0.5?-1:1;
        game.ballVX = dir * base;
        game.ballVY = -base * (gentle ? 0.7 : 1);
        tDrift = 0;
    }

    function initGame(vw, vh) {
        const scale = parseFloat(els.paddleSize.value);
        game.paddleBaseW = Math.max(90, Math.floor(vw * 0.12 * scale));
        game.paddleH = 14;
        game.paddleX = vw/2 - effectivePaddleW()/2;

        initBricks(vw,vh);
        resetBall(vw,vh);

        elapsed = 0;
        misses = 0;
        commission = 0;
        omission = 0;
        streakSec = 0;
        bestStreak = 0;
        streakHistory.length = 0;
        hitIntervals.length = 0;
        lastHitAt = 0;

        updateHUD();
        sessionStart = performance.now();
        els.bar.style.width = "0%";
        showMsg("시작: 얼굴로 패들을 조종하세요", 900);

        if (els.mode.value === "classic") {
            els.modeHint.textContent = "기본 집중: 속도가 빠르게 증가합니다.";
            els.legend.style.display = "none";
        } else if (els.mode.value === "cpt") {
            els.modeHint.textContent = "CPT: 속도는 빠르고, 공의 궤적이 더 크게 변합니다(주의 일관성).";
            els.legend.style.display = "none";
        } else {
            els.modeHint.textContent = "Go/No-Go: 궤적은 일정하고, 빨간 금지(X) 블록이 많습니다.";
            els.legend.style.display = "block";
        }
    }

    /* ====== 그리기 ====== */
    function draw(ctx, vw, vh) {
        for (const b of game.bricks) if (b.alive) {
            if (b.type === "nogo") {
                ctx.fillStyle = "#e60023";
                ctx.fillRect(b.x, b.y, game.brickW, game.brickH);
                ctx.strokeStyle = "#111";
                ctx.lineWidth = 2;
                ctx.strokeRect(b.x+0.5, b.y+0.5, game.brickW-1, game.brickH-1);
                ctx.fillStyle = "#111";
                ctx.font = "bold 14px system-ui";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("✖", b.x + game.brickW/2, b.y + game.brickH/2 + 0.5);
            } else {
                ctx.fillStyle = (els.mode.value === "cpt") ? "#dcd6c7" : "#e7e2d6";
                ctx.fillRect(b.x, b.y, game.brickW, game.brickH);
                ctx.strokeStyle = "#b9b3a6";
                ctx.strokeRect(b.x+0.5, b.y+0.5, game.brickW-1, game.brickH-1);
            }
        }

        const w = effectivePaddleW();
        ctx.fillStyle = "#111";
        ctx.fillRect(game.paddleX, vh - 36, w, game.paddleH);

        ctx.fillStyle = "#111";
        ctx.beginPath();
        ctx.arc(game.ballX, game.ballY, game.ballR, 0, Math.PI*2);
        ctx.fill();
    }

    /* ====== 업데이트 ====== */
    function update(dt, vw, vh) {
        const mode = els.mode.value;

        if (mode === "classic") {
            // ★ 속도 증가율 대폭 상향: 0.35 → 0.8, 0.02 → 0.05
            const t = Math.min(1, elapsed / SESSION_SEC);
            const mul = 1 + 0.8*t;
            game.ballVX *= (1 + (mul-1)*0.05*dt*60);
            game.ballVY *= (1 + (mul-1)*0.05*dt*60);

            const spd = Math.hypot(game.ballVX, game.ballVY);
            // ★ 상한 상향: 320 → 480
            const cap = 480;
            if (spd > cap) {
                const k = cap/spd;
                game.ballVX *= k;
                game.ballVY *= k;
            }
        } else if (mode === "cpt") {
            // ★ 목표 속도 상향: 300 → 450
            const target = 450;
            tDrift += dt;
            
            // ★ 궤적 변동 폭 대폭 증가
            const ax = 120 * Math.sin(tDrift * 3.2) + 56 * Math.sin(tDrift * 6.4);
            const ay = 84 * Math.cos(tDrift * 2.8) + 36 * Math.cos(tDrift * 5.1);

            const vmag = Math.hypot(game.ballVX, game.ballVY) || 1;
            const nx = -game.ballVY / vmag;
            const ny = game.ballVX / vmag;

            // ★ 컬링 강도 증가: 90 → 180
            const curl = 180 * Math.sin(tDrift * 1.8);

            game.ballVX += (ax + nx * curl) * 0.08;
            game.ballVY += (ay + ny * curl) * 0.08;

            // ★ 랜덤 노이즈 증가: 2.0 → 5.0
            game.ballVX += (Math.random() - 0.5) * 5.0;
            game.ballVY += (Math.random() - 0.5) * 5.0;

            const spd = Math.hypot(game.ballVX, game.ballVY) || 1;
            const k = clamp(target / spd, 0.88, 1.12);
            game.ballVX *= k;
            game.ballVY *= k;
        } else if (mode === "gng") {
            const spd = Math.hypot(game.ballVX, game.ballVY);
            // ★ 상한 상향: 250 → 420
            const cap = 420;
            if (spd > cap) {
                const k = cap/spd;
                game.ballVX*=k;
                game.ballVY*=k;
            }
        }

        game.ballX += game.ballVX * dt;
        game.ballY += game.ballVY * dt;

        if (game.ballX - game.ballR < 0) {
            game.ballX = game.ballR;
            game.ballVX *= -1;
        }
        if (game.ballX + game.ballR > vw) {
            game.ballX = vw - game.ballR;
            game.ballVX *= -1;
        }
        if (game.ballY - game.ballR < 0) {
            game.ballY = game.ballR;
            game.ballVY *= -1;
        }

        const w = effectivePaddleW();
        const py = vh - 36;
        const hitPaddle = (game.ballY + game.ballR >= py && game.ballY + game.ballR <= py + game.paddleH &&
            game.ballX >= game.paddleX && game.ballX <= game.paddleX + w);

        if (hitPaddle) {
            const hit = (game.ballX - (game.paddleX + w/2)) / (w/2);
            const speed = Math.hypot(game.ballVX, game.ballVY) * 1.03;
            const angle = hit * (Math.PI/3);
            game.ballVX = Math.sin(angle) * speed;
            game.ballVY = -Math.cos(angle) * speed;
            game.ballY = py - game.ballR - 0.1;

            streakSec += dt;
            bestStreak = Math.max(bestStreak, streakSec);

            const nowT = performance.now();
            if (lastHitAt) hitIntervals.push((nowT - lastHitAt)/1000);
            lastHitAt = nowT;
        }

        for (const b of game.bricks) if (b.alive) {
            if (game.ballX + game.ballR > b.x && game.ballX - game.ballR < b.x + game.brickW &&
                game.ballY + game.ballR > b.y && game.ballY - game.ballR < b.y + game.brickH) {

                if (b.type === "nogo") {
                    commission += 1;
                    showMsg("금지 자극 반응(Commission)", 800);

                    const overlapT = game.ballY + game.ballR - b.y;
                    const overlapB = (b.y + game.brickH) - (game.ballY - game.ballR);
                    const overlapL = game.ballX + game.ballR - b.x;
                    const overlapR = (b.x + game.brickW) - (game.ballX - game.ballR);
                    const minOverlap = Math.min(overlapL, overlapR, overlapT, overlapB);

                    if (minOverlap === overlapL) game.ballVX = -Math.abs(game.ballVX);
                    else if (minOverlap === overlapR) game.ballVX = Math.abs(game.ballVX);
                    else if (minOverlap === overlapT) game.ballVY = -Math.abs(game.ballVY);
                    else game.ballVY = Math.abs(game.ballVY);

                    streakSec = 0;
                } else {
                    b.alive = false;

                    const overlapT = game.ballY + game.ballR - b.y;
                    const overlapB = (b.y + game.brickH) - (game.ballY - game.ballR);
                    const overlapL = game.ballX + game.ballR - b.x;
                    const overlapR = (b.x + game.brickW) - (game.ballX - game.ballR);
                    const minOverlap = Math.min(overlapL, overlapR, overlapT, overlapB);

                    if (minOverlap === overlapL) game.ballVX = -Math.abs(game.ballVX);
                    else if (minOverlap === overlapR) game.ballVX = Math.abs(game.ballVX);
                    else if (minOverlap === overlapT) game.ballVY = -Math.abs(game.ballVY);
                    else game.ballVY = Math.abs(game.ballVY);
                }
                break;
            }
        }

        if (game.ballY - game.ballR > vh) {
            misses += 1;
            omission += 1;
            if (streakSec > 0.2) streakHistory.push(streakSec);
            bestStreak = Math.max(bestStreak, streakSec);
            streakSec = 0;
            showMsg("놓침: 다시 집중", 900);
            resetBall(vw, vh, true);
        }

        if (!hitPaddle) streakSec += dt;
    }

    function updateHUD() {
        els.timeLeft.textContent = (Math.max(0, SESSION_SEC - elapsed)).toFixed(1)+"s";
        els.streak.textContent = streakSec.toFixed(1)+"s";
        els.best.textContent = bestStreak.toFixed(1)+"s";
        els.miss.textContent = String(misses);
        els.comm.textContent = String(commission);
        els.omiss.textContent = String(omission);
        els.bar.style.width = Math.min(100, (elapsed/SESSION_SEC)*100) + "%";
    }

    function showMsg(text, dur=700) {
        els.msg.textContent = text;
        els.msg.classList.add('show');
        clearTimeout(showMsg.tid);
        showMsg.tid = setTimeout(()=>els.msg.classList.remove('show'), dur);
    }

    /* ====== 판정: 난이도 상향에 따른 기준 강화 ====== */
    function assessResultByMode({mode, bestN, avgN, comm, omiss, rtStd}) {
        if (mode === "classic") {
            // ★ 높음: bestN < 12, omiss >= 6, misses >= 8
            if (bestN < 12 || omiss >= 6 || misses >= 8) {
                return {
                    label:"ADHD 의심 단계: 높음",
                    cls:"error",
                    tip:"연속 집중이 짧거나 놓침이 잦습니다. 환경 자극 줄이기와 짧은 리듬 훈련 권장."
                };
            }
            // ★ 안정: bestN >= 22, avgN >= 12, omiss <= 2, misses <= 3
            if (bestN >= 22 && avgN >= 12 && omiss <= 2 && misses <= 3) {
                return {
                    label:"ADHD 의심 단계: 안정",
                    cls:"ok",
                    tip:"집중 지속이 비교적 안정적입니다. 현재 루틴 유지."
                };
            }
            return {
                label:"ADHD 의심 단계: 중간",
                cls:"warn",
                tip:"일시적 변동이 있습니다. 3–4분 집중/1분 휴식 루틴을 권장."
            };
        }

        if (mode === "cpt") {
            // ★ 높음: bestN < 10, rtStd > 0.50, omiss >= 6
            if (bestN < 10 || (rtStd && rtStd > 0.50) || omiss >= 6) {
                return {
                    label:"ADHD 의심 단계: 높음",
                    cls:"error",
                    tip:"주의 일관성 저하 또는 반응 변동성이 큼. 자극 단순화가 도움."
                };
            }
            // ★ 안정: bestN >= 25, avgN >= 14, rtStd <= 0.30, omiss <= 2
            if (bestN >= 25 && avgN >= 14 && (rtStd || 0) <= 0.30 && omiss <= 2) {
                return {
                    label:"ADHD 의심 단계: 안정",
                    cls:"ok",
                    tip:"가변 궤적에서도 안정적 리듬을 유지했습니다."
                };
            }
            return {
                label:"ADHD 의심 단계: 중간",
                cls:"warn",
                tip:"리듬이 다소 흔들립니다. 시각 신호 단순화·호흡 페이싱 활용."
            };
        }

        if (mode === "gng") {
            // ★ 높음: comm >= 3, omiss >= 7
            if (comm >= 3 || omiss >= 7) {
                return {
                    label:"ADHD 의심 단계: 높음",
                    cls:"error",
                    tip:"반응 억제가 어렵거나 놓침 누적."
                };
            }
            // ★ 안정: comm <= 1, omiss <= 2, bestN >= 16
            if (comm <= 1 && omiss <= 2 && bestN >= 16) {
                return {
                    label:"ADHD 의심 단계: 안정",
                    cls:"ok",
                    tip:"반응 억제가 전반적으로 양호합니다(금지 반응 0–1회)."
                };
            }
            return {
                label:"ADHD 의심 단계: 중간",
                cls:"warn",
                tip:"상황에 따라 충동 반응이 나타날 수 있습니다."
            };
        }

        return {
            label:"참고 결과",
            cls:"warn",
            tip:"모드 인식 오류."
        };
    }

    function exportPNG() {
        const resultCard = document.querySelector('.card');
        if (!resultCard) {
            console.error('결과 카드를 찾을 수 없습니다.');
            return;
        }

        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js';
        script.onload = () => {
            html2canvas(resultCard, {
                backgroundColor: '#f2efe7',
                scale: 2,
                useCORS: true,
                allowTaint: true,
                width: resultCard.offsetWidth,
                height: resultCard.offsetHeight
            }).then(canvas => {
                const url = canvas.toDataURL("image/png");
                const a = document.createElement('a');
                a.href = url;
                a.download = `focus-breakout-result_${Date.now()}.png`;
                a.click();
            }).catch(err => {
                console.error('캡처 실패:', err);
                alert('결과 저장에 실패했습니다. 다시 시도해주세요.');
            });
        };
        script.onerror = () => {
            console.error('html2canvas 로드 실패');
            alert('결과 저장 기능을 로드할 수 없습니다.');
        };
        document.head.appendChild(script);
    }

    /* ====== 세션 종료 & 결과 모달 ====== */
    function endSession() {
        gameOn = false;
        if (streakSec > 0.2) streakHistory.push(streakSec);

        const avg = streakHistory.length ? (streakHistory.reduce((a,b)=>a+b,0)/streakHistory.length) : 0;
        const rtMean = hitIntervals.length ? (hitIntervals.reduce((a,b)=>a+b,0)/hitIntervals.length) : 0;
        const rtStd = hitIntervals.length ? Math.sqrt(hitIntervals.reduce((a,b)=>a+(b-rtMean)*(b-rtMean),0)/hitIntervals.length) : 0;

        const modeName = els.mode.value==="classic" ? "기본 집중" :
                        els.mode.value==="cpt" ? "CPT(지속 주의)" :
                        "Go/No-Go(반응 억제)";

        const construct = els.mode.value==="classic" ? "지속적 주의 유지(몰입 지속)" :
                         els.mode.value==="cpt" ? "지속 주의 + 주의 일관성" :
                         "반응 억제(충동성) + 오류 유형";

        els.rConstructBadge.textContent = `평가 초점: ${construct}`;
        els.rMode.textContent = modeName;
        els.rBest.textContent = `${bestStreak.toFixed(1)}초`;
        els.rAvg.textContent = `${avg.toFixed(1)}초`;
        els.rMiss.textContent = String(misses);
        els.rComm.textContent = String(commission);
        els.rOmiss.textContent = String(omission);
        els.rRT.textContent = rtMean ? `${rtMean.toFixed(2)}초` : "-";
        els.rRTV.textContent = rtStd ? `${rtStd.toFixed(2)}초` : "-";

        const vw = els.video.clientWidth;
        const currentW = effectivePaddleW();
        const baselineW = vw * 0.12 * 1.2;
        const Cp = Math.max(0.6, Math.min(2.0, currentW / baselineW));

        const bestNorm = bestStreak / Cp;
        const avgNorm = avg / Cp;

        const a = assessResultByMode({
            mode: els.mode.value,
            bestN: bestNorm,
            avgN: avgNorm,
            comm: commission,
            omiss: omission,
            rtStd
        });

        els.rAssess.textContent = `${a.label} — ${a.tip}`;
        els.rAssess.className = a.cls;

        els.result.style.display = "grid";

        if (window.musicControls) {
            window.musicControls.stop();
        }
    }

    /* ====== 가이드 ====== */
    function getModeGuide(mode){
        if (mode === "classic") {
            return {
                title: "기본 집중 (60초)",
                subtitle: "목표: 공을 끝까지 떨어뜨리지 않기",
                bullets: [
                    "얼굴을 좌우로 움직여 패들의 위치를 맞춥니다(거울 모드).",
                    "속도는 빠르게 올라갑니다. 호흡을 길게, 시선을 공에.",
                    "연속해서 맞출수록 집중 연속 시간이 늘어납니다."
                ]
            };
        } else if (mode === "cpt") {
            return {
                title: "CPT – 지속 주의 (60초)",
                subtitle: "목표: 궤적이 흔들리는 공을 안정적으로 받아내기",
                bullets: [
                    "속도는 빠르고 공의 궤적이 크게 요동합니다.",
                    "패들 중앙을 유지하며 리듬을 잃지 않는 것이 포인트입니다."
                ]
            };
        } else {
            return {
                title: "Go/No-Go – 반응 억제 (60초)",
                subtitle: "목표: 타깃은 맞추고, 빨간 금지(X)는 피하기",
                bullets: [
                    "반사 각도를 섬세하게 조절하세요.",
                    "금지 블록을 치면 Commission, 타깃을 놓치면 Omission으로 기록됩니다.",
                    "금지 블록 비율이 높습니다. 신중하게 플레이하세요."
                ]
            };
        }
    }

    function openGuide(){
        const mode = els.mode.value;
        const g = getModeGuide(mode);
        els.guideTitle.textContent = g.title;
        els.guideSubtitle.textContent = g.subtitle;
        els.guideList.innerHTML = g.bullets.map(s=>`<li>${s}</li>`).join("");
        els.chkNoShow.checked = false;
        els.guideModal.style.display = "grid";
    }

    function closeGuide(){
        els.guideModal.style.display = "none";
    }

    /* ====== 메인 루프 ====== */
    function loop(now) {
        if (!running) return;

        const ctx = els.canvas.getContext('2d');
        ctx.clearRect(0,0,els.canvas.width, els.canvas.height);

        let res = null;
        try {
            if (faceLandmarker && els.video.readyState >= 2) {
                res = faceLandmarker.detectForVideo(els.video, now);
            }
        } catch (e) {
            console.error(e);
            setStatus("추적 오류(권한/조명 확인)", "error");
        }

        ctx.save();
        ctx.scale(devicePixelRatio, devicePixelRatio);

        const vw = els.video.clientWidth, vh = els.video.clientHeight;

        if (res?.faceLandmarks?.length) {
            const { cx } = getBBox(res.faceLandmarks[0], vw, vh);
            const w = effectivePaddleW();
            const targetX = cx - w/2;
            game.paddleX = game.paddleX * 0.7 + targetX * 0.3;
            game.paddleX = Math.max(0, Math.min(vw - w, game.paddleX));
        }

        const scale = parseFloat(els.paddleSize.value);
        game.paddleBaseW = Math.max(90, Math.floor(vw * 0.12 * scale));

        const dt = Math.min(0.035, (now - lastTime)/1000);
        lastTime = now;

        if (gameOn) {
            elapsed = (now - sessionStart)/1000;
            if (elapsed >= SESSION_SEC) {
                updateHUD();
                draw(ctx, vw, vh);
                ctx.restore();
                endSession();
                requestAnimationFrame(loop);
                return;
            }
            update(dt, vw, vh);
            updateHUD();
        }

        draw(ctx, vw, vh);
        ctx.restore();
        requestAnimationFrame(loop);
    }

    /* ====== 이벤트 ====== */
    document.getElementById('btnCam').addEventListener('click', startCamera);

    document.getElementById('btnStart').addEventListener('click', () => {
        if (!running) return;
        const mode = els.mode.value;
        const key = 'skipGuide_' + mode;
        if (localStorage.getItem(key) === '1') {
            const vw = els.video.clientWidth, vh = els.video.clientHeight;
            initGame(vw, vh);
            gameOn = true;
            sessionStart = performance.now();
        } else {
            openGuide();
        }
    });

    els.btnGuideCancel.addEventListener('click', closeGuide);

    els.btnGuideStart.addEventListener('click', () => {
        const mode = els.mode.value;
        const key = 'skipGuide_' + mode;
        try {
            if (els.chkNoShow.checked) localStorage.setItem(key, '1');
        } catch(e) {}
        closeGuide();
        const vw = els.video.clientWidth, vh = els.video.clientHeight;
        initGame(vw, vh);
        gameOn = true;
        sessionStart = performance.now();

        if (window.musicControls && !window.musicControls.isMuted) {
            window.musicControls.reset();
            window.musicControls.play();
        }
    });

    document.addEventListener('click', (e)=>{
        if (e.target.id === 'btnRestart') {
            els.result.style.display = "none";
            const vw = els.video.clientWidth, vh = els.video.clientHeight;
            initGame(vw, vh);
            gameOn = true;
            sessionStart = performance.now();

            if (window.musicControls && !window.musicControls.isMuted) {
                window.musicControls.reset();
                window.musicControls.play();
            }
        }
        if (e.target.id === 'btnClose') els.result.style.display = "none";
        if (e.target.id === 'btnSavePNG') exportPNG();
    });

    document.getElementById('paddleSize').addEventListener('input', () => {
        if (!running) return;
        const vw = els.video.clientWidth;
        const oldW = effectivePaddleW();
        const center = game.paddleX + oldW/2;
        game.paddleBaseW = Math.max(90, Math.floor(vw * 0.12 * parseFloat(els.paddleSize.value)));
        const newW = effectivePaddleW();
        game.paddleX = Math.max(0, Math.min(vw - newW, center - newW/2));
    });

    addEventListener('pagehide', () => {
        running = false;
        const s = els.video.srcObject;
        s && s.getTracks().forEach(t=>t.stop());
        faceLandmarker && faceLandmarker.close && faceLandmarker.close();
    });

    requestAnimationFrame(loop);

    /* ===== 음악 컨트롤 시스템 ===== */
    window.musicControls = {
        audio: null,
        isPlaying: false,
        isMuted: false,
        volume: 0.5,

        init() {
            this.audio = new Audio('game1.mp3');
            this.audio.loop = true;
            this.audio.volume = this.volume;

            els.btnStart.addEventListener('click', () => {
                if (!this.isMuted) {
                    this.reset();
                    this.play();
                }
            });

            document.addEventListener('gameEnd', () => {
                this.stop();
            });

            document.getElementById('musicToggle').addEventListener('click', () => {
                this.toggle();
            });

            document.getElementById('volumeSlider').addEventListener('input', (e) => {
                this.setVolume(e.target.value / 100);
            });
        },

        play() {
            if (this.audio && !this.isMuted) {
                this.audio.play().catch(e => console.log('Audio play failed:', e));
                this.isPlaying = true;
                this.updateToggleButton();
            }
        },

        stop() {
            if (this.audio) {
                this.audio.pause();
                this.isPlaying = false;
                this.updateToggleButton();
            }
        },

        reset() {
            if (this.audio) {
                this.audio.pause();
                this.audio.currentTime = 0;
                this.isPlaying = false;
                this.updateToggleButton();
            }
        },

        toggle() {
            this.isMuted = !this.isMuted;
            if (this.isMuted) {
                this.stop();
            } else {
                this.play();
            }
            this.updateToggleButton();
        },

        setVolume(volume) {
            this.volume = volume;
            if (this.audio) {
                this.audio.volume = this.isMuted ? 0 : this.volume;
            }
        },

        updateToggleButton() {
            const toggle = document.getElementById('musicToggle');
            if (this.isMuted) {
                toggle.classList.add('muted');
                toggle.textContent = '♫';
            } else {
                toggle.classList.remove('muted');
                toggle.textContent = '♪';
            }
        }
    };

    musicControls.init();
</script>

</body>
</html>